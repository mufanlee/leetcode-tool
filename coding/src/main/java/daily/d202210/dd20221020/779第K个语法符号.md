# [779. 第K个语法符号](https://leetcode.cn/problems/k-th-symbol-in-grammar/)

### 题目（中等）

我们构建了一个包含 `n` 行( **索引从 1 开始** )的表。首先在第一行我们写上一个 `0`。接下来的每一行，将前一行中的`0`
替换为`01`，`1`替换为`10`。

* 例如，对于 `n = 3` ，第 `1` 行是 `0` ，第 `2` 行是 `01` ，第3行是 `0110` 。

给定行数 `n` 和序数 `k`，返回第 `n` 行中第 `k` 个字符。（ `k` **从索引 1 开始**）

<br />


**示例 1:**

```
输入: n = 1, k = 1
输出: 0
解释: 第一行：0
```

**示例 2:**

```
输入: n = 2, k = 1
输出: 0
解释:
第一行: 0
第二行: 01
```

**示例 3:**

```
输入: n = 2, k = 2
输出: 1
解释:
第一行: 0
第二行: 01
```

**提示:**

* `1 <= n <= 30`
* `1 <= k <= 2`^n - 1^

### 解题思路

#### 方法一：递归

- 第 $i$ 行有 $2^{i-1}$ 个数字； 
- 第 $i$ 行 第 $j$ 个数字可以生成第 $i+1$ 行中第 $2*j-1$ 和 $2*j$ 个数字；
- 即对于第 $i+1$ 行中的第 $x$ 个数字 $num1$，会由第 $i$ 行中第 $\\lfloor \\frac{x + 1}{2} \\rfloor$ 数字生成；
- `num1 = (x & 1) ^ 1 ^ nums2`。

##### 复杂度分析

- 时间复杂度：$O(n)$。
- 空间复杂度：$O(1)$。

#### 方法二：递归

- 每一行后半部分恰好为前半部分的翻转；
- 对于查询某一行的第 $k$ 个数字，如果 $k$ 在后半部分，那么可以转化为求解该行前半部分对应位置的翻转数字；如果在前半部分，则可以转化为求解上一行对应位置的的数字。

##### 复杂度分析

- 时间复杂度：$O(n)$。
- 空间复杂度：$O(1)$。

#### 方法三：位运算

题目中索引从 $1$ 开始，我们将 $k$ 改成 $k-1$，将索引转换为从 $0$ 开始。在接下来的讨论中，索引均从 $0$ 开始。
仔细观察，一行中的第 $i$ 个字符，会在第 $2i$ 和第 $2i+1$ 个位置产生两个字符。

```0 1 1 0 1 0 0 1 1 0 0 1 0 1 1 0```

如果第 $i$ 个字符是 $0$，那么在位置 $2i$ 和 $2i+1$ 产生的字符分别是 $0$ 和 $1$；如果第 $i$ 个字符是 $1$，产生的字符是 $1$ 和
$0$。

```0 1 1 0 1 0 0 1 1 0 0 1 0 1 1 0```

```0 1 1 0 1 0 0 1 1 0 0 1 0 1 1 0```

可以发现，第 $2i$ （偶数位）个字符总是和第 $i$ 个字符相同，而第 $2i+1$ （奇数位）个字符是第 $i$
个字符的反转。也就是说，奇数位上的字符总是发生了一次反转而来的。反转偶数次，字符不变；反转奇数次，相当于反转了一次。

因此，我们只需要看 $k$ 这个数字是否是奇数，若是，累计一次反转。然后将 $k$ 除以 $2$，继续判断，并累计反转次数，直至 $k$ 为 $0$。

最后判断反转的次数是否为奇数，是则答案为 $1$，否则为 $0$。以上累计反转次数的过程，实际上等价于求 $k$ 的二进制表示中，有多少位是
$1$。

##### 复杂度分析

- 时间复杂度：$O(logk)$。
- 空间复杂度：$O(1)$。

### 代码

```java
class Solution {
    public int kthGrammar(int n, int k) {
        if (n == 1) return 0;
        return (k & 1) ^ 1 ^ kthGrammar(n - 1, (k + 1) / 2);
    }
}
```

```java
class Solution {
    public int kthGrammar(int n, int k) {
        if (k == 1) {
            return 0;
        }
        if (k > (1 << (n - 2))) {
            return 1 ^ kthGrammar(n - 1, k - (1 << (n - 2)));
        }
        return kthGrammar(n - 1, k);
    }
}
```

```java
class Solution {
    public int kthGrammar(int n, int k) {
        return Integer.bitCount(k - 1) & 1;
    }
}
```