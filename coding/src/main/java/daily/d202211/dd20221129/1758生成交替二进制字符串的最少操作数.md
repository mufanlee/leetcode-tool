# [1758. 生成交替二进制字符串的最少操作数](https://leetcode.cn/problems/minimum-changes-to-make-alternating-binary-string/)

### 题目（简单）

给你一个仅由字符 `'0'` 和 `'1'` 组成的字符串 `s` 。一步操作中，你可以将任一 `'0'` 变成 `'1'` ，或者将 `'1'` 变成 `'0'` 。

**交替字符串** 定义为：如果字符串中不存在相邻两个字符相等的情况，那么该字符串就是交替字符串。例如，字符串 `"010"` 是交替字符串，而字符串 `"0100"` 不是。

返回使 `s` 变成 **交替字符串** 所需的 **最少** 操作数。

**示例 1：**

```
输入：s = "0100"
输出：1
解释：如果将最后一个字符变为 '1' ，s 就变成 "0101" ，即符合交替字符串定义。
```

**示例 2：**

```
输入：s = "10"
输出：0
解释：s 已经是交替字符串。
```

**示例 3：**

```
输入：s = "1111"
输出：2
解释：需要 2 步操作得到 "0101" 或 "1010" 。
```

**提示：**

* `1 <= s.length <= 10`^4^
* `s[i]` 是 `'0'` 或 `'1'`


### 解题思路

#### 方法：模拟

- 根据题意，经过多次操作，`s` 可能会变成两种不同的交替二进制字符串，即：

  - 开头为 `0`，后续交替的字符串；
  - 开头为 `1`，后续交替的字符串。
- 对于 `s`，假设我们需要花费 `cnt` 次操作将其变为「从 0 开始的交替串」，那么我们想要将其变为「从 1 开始的交替串」则需要 `n - cnt` 次操作：原本操作的 `cnt` 个位置不能动，而原本没操作的位置则都需要翻转，从而确保两种交替串对应位均相反。

##### 复杂度分析

- 时间复杂度：$O(n)$。
- 空间复杂度：$O(1)$。

### 代码

```java
class Solution {
    public int minOperations(String s) {
        int cnt = 0;
        for (int i = 0; i < s.length(); i++) {
            cnt += (s.charAt(i) - '0') ^ (i & 1);
        }
        return Math.min(cnt, s.length() - cnt);
    }
}
```
