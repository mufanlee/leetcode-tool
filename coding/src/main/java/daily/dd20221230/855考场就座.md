# [855. 考场就座](https://leetcode.cn/problems/exam-room/)

### 题目（中等）

在考场里，一排有 `N` 个座位，分别编号为 `0, 1, 2, ..., N-1` 。

当学生进入考场后，他必须坐在能够使他与离他最近的人之间的距离达到最大化的座位上。如果有多个这样的座位，他会坐在编号最小的座位上。(另外，如果考场里没有人，那么学生就坐在 0 号座位上。)

返回 `ExamRoom(int N)` 类，它有两个公开的函数：其中，函数 `ExamRoom.seat()` 会返回一个 `int` （整型数据），代表学生坐的位置；函数 `ExamRoom.leave(int p)` 代表坐在座位 `p` 上的学生现在离开了考场。每次调用 `ExamRoom.leave(p)` 时都保证有学生坐在座位 `p` 上。

**示例：**

```
输入：["ExamRoom","seat","seat","seat","seat","leave","seat"], [[10],[],[],[],[],[4],[]]
输出：[null,0,9,4,2,null,5]
解释：
ExamRoom(10) -> null
seat() -> 0，没有人在考场里，那么学生坐在 0 号座位上。
seat() -> 9，学生最后坐在 9 号座位上。
seat() -> 4，学生最后坐在 4 号座位上。
seat() -> 2，学生最后坐在 2 号座位上。
leave(4) -> null
seat() -> 5，学生最后坐在 5 号座位上。
```

**提示：**

1. `1 <= N <= 10^9`
2. 在所有的测试样例中 `ExamRoom.seat()` 和 `ExamRoom.leave()` 最多被调用 `10^4` 次。
3. 保证在调用 `ExamRoom.leave(p)` 时有学生正坐在座位 `p` 上。


### 解题思路

#### 方法：有序集合

- 对于给定区间 $[s_1, s_2]$，区间中点 $s = (s1 + s2) / 2$ 为能够使进入的学生与离他最近的人之间的距离最大化；
- 将已选座位放到有序集合中；
- `seat()`：遍历有序集合找到最大化的中点位置；
- `leave()`：从有序集合中移除该位置。

##### 复杂度分析

- 时间复杂度：$O(n)$。
- 空间复杂度：$O(n)$。

### 代码

```java
class ExamRoom {
    private final TreeSet<Integer> set;

    private final int n;

    public ExamRoom(int n) {
        this.set = new TreeSet<>();
        this.n = n;
    }

    public int seat() {
        if (set.isEmpty()) {
            this.set.add(0);
            return 0;
        }

        int l = set.first(), d = set.first(), id = 0;
        for (int r : set) {
            if (d < (r - l) / 2) {
                d = (r - l) / 2;
                id = (l + r) / 2;
            }
            l = r;
        }

        int t = n - 1 - set.last();
        if (t > d) {
            id = n - 1;
        }
        set.add(id);
        return id;
    }

    public void leave(int p) {
        set.remove(p);
    }
}

/**
 * Your ExamRoom object will be instantiated and called as such:
 * ExamRoom obj = new ExamRoom(n);
 * int param_1 = obj.seat();
 * obj.leave(p);
 */
```
